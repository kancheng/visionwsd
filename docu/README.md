# Docu

這段代碼是一個基於 Flask 框架的 Web 應用，用來接收用戶上傳的圖片或影片，並透過 YOLO 模型進行物件偵測與分割處理。下面我將分段進行分析：

## app.py

Flask 框架

### 1. 基本設置與初始化

- **Flask 與其他庫的引入：**  
  引入了 Flask、OpenCV（cv2）、os、uuid、threading 以及 ultralytics 的 YOLO 模型。  
  - `Flask` 用於構建 Web 服務。
  - `cv2` 處理圖片與影片的讀寫與處理。
  - `uuid` 用於生成唯一工作 ID，方便追蹤上傳檔案的處理狀態。
  - `threading` 則用來在後台非同步處理上傳的檔案。

- **資料夾設置：**  
  指定了上傳檔案存放的資料夾 (`UPLOAD_FOLDER`) 和結果存放資料夾 (`RESULT_FOLDER`，位於 static/results 下)。使用 `os.makedirs` 確保這些資料夾存在。

- **模型加載：**  
  使用 `YOLO("yolov8n-seg.pt")` 載入 YOLO 模型，該模型支援物件檢測與分割任務。

- **全域工作字典：**  
  使用一個全域字典 `jobs` 來追蹤每個上傳檔案的處理進度、結果檔案名稱以及檔案類型（圖片或影片）。字典結構如下：  
  ```python
  jobs[job_id] = {"progress": int, "result_file": str, "file_type": "image" 或 "video"}
  ```

### 2. 圖片處理函式：`process_image`

- **進度模擬：**  
  先將進度設置為 10%，接著對圖片進行 YOLO 推論後再將進度更新到 50%。

- **模型推論與結果儲存：**  
  調用模型對上傳圖片進行處理，並使用 `results[0].plot()` 將結果（例如在物件上繪製框或遮罩）轉為圖片。  
  結果圖片以 `cv2.imwrite` 寫入指定的結果資料夾，檔案名稱前加上 "result_"。

- **進度最終更新：**  
  完成後將進度更新到 100%，並在 `jobs` 字典中記錄結果檔案名稱與檔案類型為 "image"。

### 3. 影片處理函式：`process_video`

- **影片讀取與初始化：**  
  使用 `cv2.VideoCapture` 讀取影片，並獲取影片的總幀數、幀率、寬高等資訊。  
  設定輸出影片的編碼方式（使用 `avc1` 編碼）並強制輸出為 mp4 格式。

- **逐幀處理：**  
  進入一個迴圈，逐幀讀取影片。  
  對每一幀使用 YOLO 模型進行推論，並將處理結果轉為圖片（透過 `results[0].plot()`）。  
  每處理一幀就寫入輸出影片，同時根據當前幀數更新工作進度（以百分比表示）。

- **影片釋放與完成更新：**  
  當所有幀處理完畢後，釋放讀取與寫入資源，並將進度設置為 100%。  
  在 `jobs` 字典中記錄結果檔案名稱以及檔案類型為 "video"。

### 4. Flask 路由

- **首頁路由 (`/`)：**  
  返回首頁模板 `index.html`。這通常是前端頁面，讓用戶上傳檔案。

- **上傳路由 (`/upload`)：**  
  處理用戶上傳的檔案：
  - 檢查是否有上傳檔案，然後保存到 `UPLOAD_FOLDER` 資料夾中。
  - 根據檔案副檔名判斷檔案類型（圖片或影片）。
  - 為每個上傳的檔案生成一個唯一的 `job_id`，並在全域字典 `jobs` 中初始化該工作狀態。
  - 根據檔案類型，啟動一個背景線程來執行 `process_image` 或 `process_video` 處理任務。  
  最後返回一個 JSON 格式的回應，其中包含 `job_id`，前端可以利用這個 ID 來查詢處理進度。

- **進度查詢路由 (`/progress`)：**  
  根據前端傳入的 `job_id` 返回該工作的進度、結果檔案名稱及檔案類型。  
  如果沒有找到該 `job_id`，則返回預設的進度 0 及空的結果訊息。

### 5. 應用運行

- 在程式最後，使用 `app.run(debug=True)` 啟動 Flask 服務，這裡的 debug 模式方便在開發階段即時查看錯誤訊息及變化。

### 總結

這段代碼實現了以下幾個主要功能：

1. **上傳與儲存檔案：** 接收圖片或影片檔案，並將檔案存入指定的資料夾。
2. **背景非同步處理：** 利用 Python 的 threading 模組，在後台進行耗時的 YOLO 模型推論處理，不阻塞主線程。
3. **進度追蹤：** 透過全域字典 `jobs` 來追蹤每個工作進度，並提供一個進度查詢 API 給前端使用者實時獲取處理狀態。
4. **結果儲存與回傳：** 處理完的圖片或影片結果會存放在指定的結果資料夾中，並且通過 API 返回結果檔案名稱與檔案類型，方便前端展示處理後的結果。

## index.html

這段 HTML 代碼構成了一個前端頁面，用來展示 YOLO 等模型的檢測與分割 Demo。下面分區域說明其各部分的功能與邏輯：

### 1. HTML 結構與樣式

- **基本文件結構：**  
  文件宣告使用 HTML5，語言設定為中文（`lang="zh"`），並指定 UTF-8 編碼，確保正確顯示中文內容。

- **標題與樣式：**  
  - `<title>` 標籤設定了頁面的標題為 “YOLO 檢測與分割”。  
  - `<style>` 區塊內定義了進度條的樣式：  
    - `#progressBar` 是進度條的背景容器，寬度 100%，背景色淺灰，並有邊框。  
    - `#progressBarFill` 為實際填充的部分，初始寬度設為 0%，高度 20px，背景色綠色，文字置中且顏色為白色。

### 2. 頁面內容區域

- **上傳區 (`uploadSection`)：**  
  包含一個表單（`<form id="uploadForm">`），裡面有一個檔案上傳控件與一個上傳按鈕。使用者可在此選擇圖片或影片檔案進行上傳。

- **進度條區 (`progressSection`)：**  
  初始隱藏（`display:none;`），在上傳後顯示，包含一個標題“處理進度”及進度條元件，用於動態顯示後端處理進度。

- **結果展示區 (`resultSection`)：**  
  同樣初始隱藏，用於展示 YOLO 模型處理完畢後的結果。這裡包含一個結果容器（`resultContainer`）和一個按鈕，可以重新上傳檔案（透過頁面重新加載）。

### 3. JavaScript 控制邏輯

- **DOM 元素選取與全域變數：**  
  使用 `document.getElementById` 選取上傳表單、進度條、結果區等元素，並設定一個全域變數 `jobId` 用來儲存從後端獲取的工作 ID。

- **表單上傳事件：**  
  - 為上傳表單綁定 `submit` 事件，並使用 `event.preventDefault()` 來避免頁面預設提交。  
  - 檢查是否有選擇檔案，若無則提醒使用者。  
  - 利用 `FormData` 封裝檔案，然後使用 `fetch` 向 `/upload` 端點發送 POST 請求。  
  - 成功回應後，若後端返回 `job_id`，則儲存該 ID 並開始輪詢進度；若返回錯誤則顯示錯誤訊息。

- **進度查詢機制：**  
  - `checkProgress` 函式使用 `fetch` 向 `/progress` 端點請求當前工作進度，傳遞 `job_id` 作為查詢參數。  
  - 根據返回的 JSON 數據更新進度條的寬度與顯示文字（如 "50%"）。  
  - 若進度未達 100%，則每隔 500 毫秒重複查詢；進度達 100% 時，呼叫 `showResult` 顯示最終結果。

- **結果展示：**  
  - `showResult` 函式根據後端返回的 `file_type` 判斷結果為圖片還是影片。  
  - 若為影片，則將 `<video>` 標籤插入 `resultContainer`；若為圖片，則插入 `<img>` 標籤，並設定相應的 `src`。  
  - 同時隱藏進度條區，顯示結果區，並提供一個重新上傳的按鈕（透過 `location.reload()` 重新載入頁面）。

### 4. 整體流程

1. **上傳檔案：**  
   使用者在上傳區選擇檔案並提交表單，前端將檔案封裝後發送到後端的 `/upload` 端點。

2. **開始處理：**  
   後端回傳一個 `job_id`，前端利用該 ID 透過輪詢 `/progress` 端點獲取處理進度。

3. **動態更新進度：**  
   前端利用進度條視覺化展示處理進度，持續輪詢直到進度達 100%。

4. **展示結果：**  
   當進度完成後，根據檔案類型展示對應的處理結果（圖片或影片），並提供重新上傳的選項。
